 File "C:\model\dnnseg\bin\train.py", line 129, in <module>
    ix2label=train_data.ix2label(p['segtype']),
  File "C:\model\dnnseg\model.py", line 2295, in fit
    verbose=verbose
  File "C:\model\dnnseg\model.py", line 1924, in run_evaluation
    verbose=verbose
  File "C:\model\dnnseg\model.py", line 1682, in evaluate_classifier
    feed_dict=fd_minibatch

función fit (model 2156) usa función run_evaluation (uso en model 2285; definición en model 1852), que usa evaluate_classifier (uso en model 1915; definición en 1593) que se estanca en self.sess.run (model 1682)


INPUT

fit:
	    train_data,
            cv_data=None,
            n_iter=None,
###!!!!###  ix2label=None, ###!!!!### --> recibe train_data.ix2label(p["segtype"])
            n_plot=10,
            verbose=True

run_evaluation: (usado por fit en model 2285)
	    		cv_data if cv_data is not None else train_data,
                        X_cv=X_cv,
                        X_mask_cv=X_mask_cv,
                        y_cv=y_cv,
                        y_mask_cv=y_mask_cv,
hasta aquí es lo que se recibe de fit que se pasa a evaluate_classifier y luego de ahí a fd_minibatch

                        ix2label=ix2label,
                        y_means_cv=None if y_means_cv is None else y_means_cv,
                        segtype=self.segtype,
                        plot=True,
                        verbose=verbose

	    self,
            cv_data,
            X_cv=None,
            X_mask_cv=None,
            y_cv=None,
            y_mask_cv=None,
            n_plot=10,
###!!!!###  ix2label=ix2label, ###!!!!### --> recibe ix2label=train_data.ix2label(p["segtype"]) desde fit
            y_means_cv=None,
            training_batch_norm=False,
            training_dropout=False,
            shuffle=False,
            segtype=None,
            plot=True,
            verbose=True

evaluate_classifier: (usado por run_evaluation en model 1915)
	    		cv_data,
                        X_cv=X_cv,
                        X_mask_cv=X_mask_cv,
                        y_cv=y_cv,
                        y_mask_cv=y_mask_cv,
hasta aquí es lo que se recibe de run_evaluation que se pasa a fd_minibatch

                        segtype=segtype,
                        ix2label=ix2label,
                        plot=plot,
                        verbose=verbose
	    
	    self,
            cv_data,
            X_cv=None,
            X_mask_cv=None,
            y_cv=None,
            y_mask_cv=None,
            segtype=None,
###!!!!###  ix2label=ix2label, ###!!!!### --> recibe ix2label=train_data.ix2label(p["segtype"]) desde run_evaluation
            plot=True,
            verbose=True

            ...
	ESTA FUNCIÓN PARECE QUE SE ESTANCA POR OTRA COSA QUE NO TIENE NADA QUE VER CON EL ix2label!!!


out = self.sess.run(
                            to_run,
                            feed_dict=fd_minibatch
                        )

fd_minibatch VIENE DE input evaluate_classifier, model 1669:
fd_minibatch = {
                            self.X: X_cv[indices],
                            self.X_mask: X_mask_cv[indices],
                            self.y: y_cv[indices],
                            self.y_mask: y_mask_cv[indices],
                            self.training: False
                        }

X_cv, X_mask_cv, y_cv, y_mask_cv vienen originalmente de fit en 2180:
train_data.inputs(...)

self.X, self.X_mask, vienen originalmente de model 268 (función build, initialize inputs) y son placeholders
self.X = tf.placeholder(self.FLOAT_TF, shape=(None, self.n_timesteps_input, X_n_feats), name='X')
self.X_mask = tf.placeholder(self.FLOAT_TF, shape=(None, self.n_timesteps_input), name='X_mask')

self.y, self.y_mask vienen originalmente de model 284 (función build, initialize inputs) y son placeholders
self.y = tf.placeholder(self.FLOAT_TF, shape=(None, self.n_timesteps_output, self.frame_dim), name='y')
self.y_mask = tf.placeholder(self.FLOAT_TF, shape=(None, self.n_timesteps_output), name='y_mask')


to_run VIENE DE evaluate_classifier (usado en model 1680, definido en 1651)
to_run = []
to_run.append(self.labels_post) -->buscar
if binary:
                        ...
                        to_run += [self.encoding_post, self.encoding_entropy] --> buscar
 


self.labels_post = self.labels (usado en model 2853 en _initialize_objective definido en model 2795, _initialize_objective se utiliza en build)

self.labels = binary2integer(tf.round(encoding), session=self.sess) (usado en model 599 en _augment_encoding(encoding), _augment_encoding se utiliza en build en model 235, se define en model 594)
(o sea que encoding aquí es el argumento en la definición de _augment_encoding(encoding,...) , model 594)

... = self._augment_encoding(self.encoding, encoder=self.encoder) (en build, model 235)

self.encoder = self._initialize_encoder(self.X)  (model 233ff)
self.encoding = self._initialize_classifier(self.encoder) 
self.decoder_in, self.extra_dims = self._augment_encoding(self.encoding, encoder=self.encoder)


qué hace self._initialize_classifier ? qué hace self._initialize_encoder ??
self._initialize_classifier (model 2678) --> slope annealing
self._initialize_encoder (model 253) --> arquitectura (layers)




 File "C:\Users\Kiara\Anaconda3\envs\tf_test\lib\site-packages\tensorflow\python\client\session.py", line 877, in run run_metadata_ptr)
  File "C:\Users\Kiara\Anaconda3\envs\tf_test\lib\site-packages\tensorflow\python\client\session.py", line 1100, in _run feed_dict_tensor, options, run_metadata)
  File "C:\Users\Kiara\Anaconda3\envs\tf_test\lib\site-packages\tensorflow\python\client\session.py", line 1272, in _do_run run_metadata)
  File "C:\Users\Kiara\Anaconda3\envs\tf_test\lib\site-packages\tensorflow\python\client\session.py", line 1291, in _do_call raise type(e)(node_def, op, message)
tensorflow.python.framework.errors_impl.InternalError: Unable to get element as bytes.








